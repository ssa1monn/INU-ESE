// 배열(Arrays)

// 자료형 array : C언어에서의 derived data types 중 하나.
//  - derived data types : Fundamental data type(int, char, float, ...)을 이용해서 만들어지는 자료형

// Array는 index가 붙어있는 자료형
//  - 배열의 첨자는 0부터 시작된다.

// 변수의 종류에 관계없이 낮은 번지에서 높은 번지로 인덱스 순서대로 저장됨.

// 다른 일반 변수들은 보통 먼저 정의된 변수가 높은(큰) 번지에 만들어지고,
// 다음 정의된 변수가 낮은 번지에 만들어짐.
// ex) int a, b; a는 상대번지 163에, b는 151에 만들어짐.

// 그러나 배열은 반드시 시작점부터 데이터크기만큼 증가하며 순서대로 만들어짐.
// ex) char x[4]; 상대번지 0부터 시작하여 x[0]은 상대 0번지, x[1]은 상대 1번지, x[2]는 상대 2번지.
// (char 형은 1byte이므로 1씩 증가)

// 모든 데이터 형 (구조체 포함) 을 배열로 만들 수 있음
// 포인터도 배열의 데이터가 될 수 있음.
// 일정한 형태의 데이터가 같은 크기로 계속 반복되어 "연속"으로 저장됨.

// 그 중 char 문자는 "문장"이라는 특별함 때문에 "문자열" 이라고 한다.
// 연속으로 출력되는 등의 처리를 할 수 있기 때문에 다른 배열과 달리 주의를 기울여야 한다.

// 배열의 초기화 기본
// float f[3] = {0.0, 1.7, -9.7};
// int a[100] = {1}; // = {1,};
//  - 1 이후의 원소는 모두 0이 됨.
//  - 초기화 시키는 상수의 개수가 배열의 크기보다 적으면 이후의 원소들은 모두 0으로 초기화

// int aa[] = {1, 2}; // = int aa[2] = {1, 2};
//  - 초기화 개수에 맞춰진다.

// if printf("%d", aa[2]); -> 쓰레기 값이 출력됨.

// ========================================================================

// 문자열(String)
//  - "I am a boy.", ""(Null string)
//  - NULL string 은 비어 있는 문자열
//  - 문자열에 NULL(값 0) 만 있다는 뜻

// ""를 쓰게 되면 자동으로 끝에 NULL 이 들어가게 됨.
//  -> NULL 문자가 들어갈 공간이 적어도 한개 있어야 함.

// NULL은 문자열의 끝을 나타내며, 문자열은 반드시 NULL로 끝나야만 한다.
// 문자열은 printf 등의 함수에서 연속으로 출력될 수도 있으르므로 끝을 지정하지 않으면 끝낼 수가 없게된다.

// 문자열은 문자(character)의 집합이다.

// " " 와 ' ' 는 다르다. C언어가 문법으로 표현하고자 하는 깊은 것을 이해해보자.
//  - " " 는 연속이기에 주소를 가짐. ' ' 는 문자 한개를 나타내므로 아스키코드 값을 가짐.
// 컴퓨터 시스템(운영체제)의 관점을 조금씩 깊게 더해보자.

// 실제 주소값이 아닌 기준점을 잡은 상대주소.

// 문자열 "I am a boy"는 메모리에 연속적으로 저장됨.
//  - 상대주소 0번지에 'I', 상대 1번지에 ' ', 상대 2번지에 'a', ... , 상대 11번지에 '\0(NULL)'.

// NULL 문자는 숫자값으로는 0. '0' 은 숫자 0의 아스키 코드 값이고, 0은 NULL 특수 문자의 값이다.

// char의 배열 = 문자열

// char tmpstr[12];
//  - tmpstr은 문자형(char) 변수 12개의 배열이다.
//  - 따라서 tmpstr은 문자(character) 12개를 저장할 수 있다.
//  - 문자열을 저장할 때는 NULL 문자도 반드시 포함되어야 하므로 실제로 저장 가능한 문자는 총 11개이다.

// "문자열을 저장한다" 는 것과 "문자(들)을 저장한다" 는 것은 저장하는 시점에서도 매우 중요하고, 사용하는 방법에서도 매우 중요하다.

// ========================================================================

// 휴대폰과 PC 의 차이.

// PC는 전원을 재시작 하는 일이 매우 많음.
//  - 휘발성인 메모리는 전원이 꺼지면 초기화 됨.

// 휴대폰은 전원을 재시작 하는 경우가 많지 않음.
//  - 어떤 앱에서 메모리에 오류를 발생시키는 경우 누적되어 문제가 생길 수 있음.

// 변수의 이름은 사용자가 사용하기 쉽게 하기 위해 존재.
//  -> 컴파일을 하면 결국 주소로 대체되는 것.

// ========================================================================

// 1차원 char 배열즤 주소와 표현
// char a[12] = "I am a boy"; // 혹은 = {'I', ' ', 'a', ...}

// 첫번째 문자의 주소가 1000 일 때, 다음과 같다
//  - a 는 1000 이다. (주소, 상수)
//  - a 는 포인터상수 이다. (변경 불가, 할당 받음)
//  - a[0] 은 'I' 이다. (char 변수)
//  - a[0] 부터 a[11] 까지 각 char 은 변수이다.
//  - &a[0] 는 a[0] 문자의 주소인 상수이다.
//  - &a[0] 는 a 와 같다.

// => 배열의 이름은 첫번째 덩어리의 주소를 나타낸다.

// ========================================================================

// 주소끼리의 차이는 계산할 수 있으나 합은 연산할 수 없다.
// a[2] - a[0] = 2; // 문자열의 요소의 개수 차이를 계산.
// a[2] + a[0] = error; // 문자열의 요소의 합은 연산할 수 없다.
// 배열 a가 int 형이여도 똑같은 값이 나옴.
// 주소값의 차이를 구하기 위해서는 배열의 자료형 level 이 중요함.

// char a[12] = "I am a boy."; 에서 실제로 컴퓨터가 하는 일

// 문자열을 제외하고는 이런 식으로 배열 값을 할당 하는 경우는 없다.

// 프로그램에서 " " 로 표현되는 문자열이 있으면 텍스트 영역에 일단 문자열을 저장.
//  - 텍스트 영역 : 코드와 같은 정해진 상수값들을 저장하는 Read Only 영역

// char 배열인 변수공간에 그 문자열을 다시 복사 해 놓는다.
// 그리고, 그 문자열의 첫번쨰 위치를 a 로 나타냄.

// 실제 컴퓨터에선 컴파일러가 모든 변수 이름을 상대 주소로 바꾸어서 처리. 
// 따라서 이 과정에서 int, char 형 등 모든 크기에 맞는 주소 계산이 이루어짐.

// a[0] ~ a[11] 까지 모든 요소는 char 값, 변수이다.
// a, &a[0] ~ &a[11] 까지 모든 요소는 주소, 상수이다. 할당을 받는 것

// ========================================================================

// 1차원 int 배열의 주소와 표현
// int i[12] = {100, 200, 300, 400, 500, };

// 첫번째 숫자의 주소가 1000 일 때, 다음과 같다.
//  - i 는 1000 이다. (주소, 상수)
//  - i 는 포인터상수 이다. (변경 불가, 할당 받음)
//  - i[0] 은 100 이다. (int 변수)
//  - i[0] 부터 i[11] 까지 각 int 은 변수이다.
//  - &i[0] 는 i[0] 숫자의 주소인 상수이다.
//  - &i[0] 는 i 와 같다.

// => 배열의 이름은 첫번째 덩어리의 주소를 나타낸다.

// ========================================================================

// 주소값의 +, - 는 "다음", "이전" 의 의미이다.

// 주소의 실제 메모리 차이를 구하기 위해서는?
//  -> (int)&i[2] - (int)&i[0] = 8;

// 각각을 주소가 아닌 숫자(정수형)으로 캐스팅 한 후 연산해야 함.
// 또는 *sizeof(int)를 해도 됨.

// ========================================================================

// 중간고사 및 예비시험 예상 일정

// 7주차 - 정상 진행
// 8주차 - 10/21 A/B 합반, 2개 강의실에서 2시간동안 중간고사 예비시험 진행. (OJT만 진행, 서버 점검, 문제 유형 점검 등
//         A반 뒤쪽 1시간 + B반 앞쪽 1시간 진행 (1 ~ 3시)
//         OJT 성적으로 반영함. 방식과 내용은 중간고사 스타일임
//         10/24 수업 없음
// 9주차 - 10/28 중간고사 (종이시험 + OJT)
//         10/21 예비시험과 OJT는 동일함.
//         종이시험은 이론수업/ 실습 시간에 진행하는 스타일을 참고할 것.
//         10/31 정상 수업